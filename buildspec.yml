version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: ap-northeast-2
    IMAGE_REPO_NAME: backend-app
    EKS_CLUSTER_NAME: my-backend-cluster
    SECRETS_MANAGER_SECRET_NAME: fall-in-jeju-dynamodb-secrets

phases:
  install:
    commands:
      - |
        set -e
        echo "===== INSTALL PHASE ====="

        # jq
        if command -v apt-get >/dev/null 2>&1; then
          apt-get update && apt-get install -y jq
        else
          yum install -y jq
        fi
        jq --version

        # kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        kubectl version --client

        # kustomize
        curl -s https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh | bash
        mv kustomize /usr/local/bin/kustomize
        kustomize version

  pre_build:
    commands:
      - |
        set -e
        echo "===== PRE BUILD ====="

        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        REPOSITORY_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}"
        IMAGE_TAG=$(echo ${CODEBUILD_RESOLVED_SOURCE_VERSION} | cut -c 1-7)

        echo "Logging in to ECR..."
        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} \
          | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com

  build:
    commands:
      - |
        set -e
        echo "===== BUILD ====="

        docker build -t ${REPOSITORY_URI}:${IMAGE_TAG} .
        docker tag ${REPOSITORY_URI}:${IMAGE_TAG} ${REPOSITORY_URI}:latest

  post_build:
    commands:
      - |
        set -e
        echo "===== POST BUILD ====="

        docker push ${REPOSITORY_URI}:${IMAGE_TAG}
        docker push ${REPOSITORY_URI}:latest

        echo "===== EKS DEPLOY ====="

        aws eks update-kubeconfig \
          --name ${EKS_CLUSTER_NAME} \
          --region ${AWS_DEFAULT_REGION}

        export KUBECONFIG=/root/.kube/config

        echo "Testing kubectl access..."
        kubectl get ns

        echo "Fetching secrets from Secrets Manager..."
        SECRET_JSON=$(aws secretsmanager get-secret-value \
          --secret-id ${SECRETS_MANAGER_SECRET_NAME} \
          --query SecretString \
          --output text)

        AWS_REGION=$(echo "$SECRET_JSON" | jq -r '."aws.region"')
        DYNAMODB_TABLE_NAME=$(echo "$SECRET_JSON" | jq -r '."aws.dynamodb.table-name"')
        DYNAMODB_ACCESS_KEY=$(echo "$SECRET_JSON" | jq -r '."aws.dynamodb.credentials.access-key"')
        DYNAMODB_SECRET_KEY=$(echo "$SECRET_JSON" | jq -r '."aws.dynamodb.credentials.secret-key"')
        BEDROCK_API_GATEWAY_URL=$(echo "$SECRET_JSON" | jq -r '."aws.bedrock.api-gateway-url"')
        TMAP_APP_KEY=$(echo "$SECRET_JSON" | jq -r '."TMAP_APP_KEY"')
        SPRING_DATASOURCE_URL=$(echo "$SECRET_JSON" | jq -r '."SPRING_DATASOURCE_URL"')
        SPRING_DATASOURCE_USERNAME=$(echo "$SECRET_JSON" | jq -r '."SPRING_DATASOURCE_USERNAME"')
        SPRING_DATASOURCE_PASSWORD=$(echo "$SECRET_JSON" | jq -r '."SPRING_DATASOURCE_PASSWORD"')

        echo "Creating Kubernetes Secret manifest..."
        cat <<EOF > /tmp/app-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: default
type: Opaque
stringData:
  aws.region: "${AWS_REGION}"
  aws.dynamodb.table-name: "${DYNAMODB_TABLE_NAME}"
  aws.dynamodb.credentials.access-key: "${DYNAMODB_ACCESS_KEY}"
  aws.dynamodb.credentials.secret-key: "${DYNAMODB_SECRET_KEY}"
  aws.bedrock.api-gateway-url: "${BEDROCK_API_GATEWAY_URL}"
  TMAP_APP_KEY: "${TMAP_APP_KEY}"
  SPRING_DATASOURCE_URL: "${SPRING_DATASOURCE_URL}"
  SPRING_DATASOURCE_USERNAME: "${SPRING_DATASOURCE_USERNAME}"
  SPRING_DATASOURCE_PASSWORD: "${SPRING_DATASOURCE_PASSWORD}"
EOF
  
  kubectl apply -f /tmp/app-secrets.yaml --validate=false
  
  echo "Applying kustomize manifests..."
  kustomize build k8s-manifests/base | kubectl apply -f - --validate=false
  
  echo "===== DEPLOY COMPLETE ====="
